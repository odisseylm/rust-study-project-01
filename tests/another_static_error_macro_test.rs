use assertables::{ assert_contains, assert_contains_as_result };

pub mod parse_currency_another_01 {
    // use project01::util::backtrace::BacktraceInfo;

    // #[derive(Debug, PartialEq, Copy, Clone)]
    #[derive(Debug, thiserror::Error)]
    #[derive(Copy, Clone)]
    #[derive(PartialOrd, PartialEq)]
    pub enum ErrorKind {
        #[error("no currency")]
        NoCurrency,
        #[error("Incorrect currency format")]
        IncorrectCurrencyFormat,
    }

    // #[derive(Debug, PartialEq, Copy, Clone)]
    #[derive(thiserror::Error)]
    #[derive(static_error_macro::MyStaticStructError)]
    // #[static_struct_error_internal_type_path_mode(ExternalCratePath)]
    pub struct CurrencyFormatError {
        pub kind: ErrorKind,
        // #[source]
        // pub source: ErrorSource,
        pub backtrace: project01::util::backtrace::BacktraceInfo,
    }

    // #[derive(thiserror::Error)]
    // pub enum ErrorSource {
    //     #[error("No source")]
    //     NoSource,
    // }

    /*
    impl CurrencyFormatError {
        // It can be generated by macro
        pub fn new(kind: ErrorKind) -> Self {
            Self { kind, backtrace: BacktraceInfo::new() }
        }
        // It can be generated by macro
        pub fn with_backtrace(kind: ErrorKind, backtrace_policy: NewBacktracePolicy) -> Self {
            Self { kind, backtrace: BacktraceInfo::new_by_policy(backtrace_policy) }
        }
    }

    // It can be generated by macro
    impl BacktraceCopyProvider for CurrencyFormatError {
        fn provide_backtrace(&self) -> BacktraceInfo { self.backtrace.clone() }
    }

    // It can be generated by macro
    impl fmt::Display for CurrencyFormatError {
        fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
            write!(f, "CurrencyFormatError  {}", self.kind)
        }
    }
    */
}



pub mod parse_amount_another_01 {
    use bigdecimal::ParseBigDecimalError;
    use crate::parse_currency_another_01::CurrencyFormatError;
    use project01::util::backtrace::BacktraceInfo;

    #[derive(Debug, thiserror::Error)]
    #[derive(Copy, Clone)]
    #[derive(PartialOrd, PartialEq)]
    pub enum ErrorKind {
        #[error("No currency in amount")]
        NoCurrency,
        #[error("Incorrect currency format")]
        IncorrectCurrency,
        #[error("Incorrect amount format")]
        IncorrectAmount,
    }

    #[derive(thiserror::Error)]
    #[derive(static_error_macro::MyStaticStructError)]
    #[static_struct_error_internal_type_path_mode(ExternalCratePath)]
    pub struct ParseAmountError {
        pub kind: ErrorKind,
        #[source]
        // #[from]
        pub source: ErrorSource,
        pub backtrace: BacktraceInfo,
    }

    // It can be generated by macro
    #[derive(static_error_macro::MyStaticStructErrorSource)]
    // Full type or short type can be used: ParseAmountError/crate::entities::amount::parse_amount::ParseAmountError
    // #[struct_error_type(ParseAmountError)]
    #[struct_error_type(ParseAmountError)]
    #[static_struct_error_internal_type_path_mode(ExternalCratePath)]
    // #[do_not_generate_std_error]
    pub enum ErrorSource {
        // #[error("No source")]
        NoSource,
        // #[error("Currency format error")]
        // #[static_error_macro::StaticStructErrorType(ParseAmountError)]
        // #[from_error_kind(IncorrectCurrency)]
        CurrencyFormatError(CurrencyFormatError),
        // for testing
        // CurrencyFormatError22(crate::entities::currency::parse_currency::CurrencyFormatError),
        // #[error("Decimal format error")]
        #[from_error_kind(IncorrectAmount)]
        #[no_source_backtrace]
        ParseBigDecimalError(ParseBigDecimalError),

        // #[no_source_backtrace]
        SomeWithoutSource,

        // With duplicated types
        // #[error("Some1FromString")]
        #[no_source_backtrace]
        // #[from_error_kind(IncorrectAmount)] // temp. to test proper 'duplicates' error
        Some1FromString(String),
        // #[error("Some2FromString")]
        #[no_source_backtrace]
        // #[from_error_kind(IncorrectAmount)] // temp. to test proper 'duplicates' error
        Some2FromString(String),
        // #[error("Some1FromInt")]
        #[no_source_backtrace]
        Some1FromInt(i32),
        // #[error("Some2FromInt")]
        #[no_source_backtrace]
        Some2FromInt(i32),

        // #[error("SomeAnyHowError")]
        SomeAnyHowError(anyhow::Error),

        // #[error("SomeStdError")]
        StdErrorError(Box<dyn std::error::Error>),
    }

    /*
    impl ParseAmountError {

        // error[E0658]: inherent associated types are unstable
        // see issue #8995 <https://github.com/rust-lang/rust/issues/8995> for more information
        //
        // type ErrorKind = ParseAmountErrorKind;

        // It can be generated by macro
        pub fn new(kind: ErrorKind) -> ParseAmountError {
            ParseAmountError { kind, source: ErrorSource::NoSource, backtrace: BacktraceInfo::new() }
        }
        // It can be generated by macro
        pub fn with_backtrace(kind: ErrorKind, backtrace_policy: NewBacktracePolicy) -> ParseAmountError {
            ParseAmountError { kind, source: ErrorSource::NoSource, backtrace: BacktraceInfo::new_by_policy(backtrace_policy) }
        }
        // It can be generated by macro
        pub fn with_source(kind: ErrorKind, source: ErrorSource) -> ParseAmountError {
            ParseAmountError { kind, backtrace: BacktraceInfo::inherit_from(&source), source }
        }
        // It can be generated by macro
        pub fn with_from<ES: Into<ErrorSource>>(kind: ErrorKind, source: ES) -> ParseAmountError {
            let src = source.into();
            ParseAmountError { kind, backtrace: BacktraceInfo::inherit_from(&src), source: src }
        }
    }

    // It can be generated by macro
    impl From<CurrencyFormatError> for ParseAmountError {
        fn from(error: CurrencyFormatError) -> Self { ParseAmountError::with_from(ErrorKind::IncorrectCurrency, error) }
    }
    // It can be generated by macro
    impl From<ParseBigDecimalError> for ParseAmountError {
        fn from(error: ParseBigDecimalError) -> Self { ParseAmountError::with_from(ErrorKind::IncorrectAmount, error) }
    }

    // It can be generated by macro
    impl Into<ErrorSource> for CurrencyFormatError {
        fn into(self) -> ErrorSource { ErrorSource::CurrencyFormatError22(self) }
    }
    // It can be generated by macro
    impl Into<ErrorSource> for ParseBigDecimalError {
        fn into(self) -> ErrorSource { ErrorSource::ParseBigDecimalError(self) }
    }

    // It can be generated by macro
    impl BacktraceCopyProvider for ErrorSource {
        fn provide_backtrace(&self) -> BacktraceInfo {
            match self {
                ErrorSource::NoSource => { BacktraceInfo::empty() }
                ErrorSource::ParseBigDecimalError(_)  => { BacktraceInfo::empty() }
                ErrorSource::CurrencyFormatError22(src) => { src.provide_backtrace() }
            }
        }
    }

    // It can be generated by macro
    impl core::fmt::Debug for ErrorSource {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
            use ErrorSource::*;
            match self {
                NoSource                      => { write!(f, "No source") }
                CurrencyFormatError22(ref src)  => { write!(f, "{:?}", src) }
                ParseBigDecimalError(ref src) => { write!(f, "{:?}", src) }
            }
        }
    }

    // It can be generated by macro
    impl core::fmt::Display for ParseAmountError {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "{}", self.kind)
        }
    }

    // impl BacktraceCopyProvider for ParseBigDecimalError {
    //     fn provide_backtrace(&self) -> BacktraceInfo { BacktraceInfo::empty() }
    // }
    */
}

// -------------------------------------------------------------------------------------------------
//                     Error without source - simple variant.
// -------------------------------------------------------------------------------------------------

use project01::util::backtrace::{is_anyhow_backtrace_enabled, NewBacktracePolicy};
use project01::util::backtrace::BacktraceCopyProvider;

#[test]
fn test_currency_format_error_new() {
    use parse_currency_another_01::*;

    let err = CurrencyFormatError::new(ErrorKind::NoCurrency);
    assert_contains!(err.backtrace.to_string(), "capture");
    assert_eq!(err.kind, ErrorKind::NoCurrency);
    assert_contains!(err.provide_backtrace().to_string(), "capture");
}

#[test]
fn test_currency_format_error_with_backtrace() {
    use parse_currency_another_01::*;

    let err = CurrencyFormatError::with_backtrace(ErrorKind::IncorrectCurrencyFormat, NewBacktracePolicy::Default);
    assert_contains!(err.backtrace.to_string(), "capture");
    assert_eq!(err.kind, ErrorKind::IncorrectCurrencyFormat);

    let err = CurrencyFormatError::with_backtrace(ErrorKind::NoCurrency, NewBacktracePolicy::Capture);
    if is_anyhow_backtrace_enabled() {
        assert_contains!(err.backtrace.to_string(), "capture");
        assert_contains!(err.provide_backtrace().to_string(), "capture");
    } else {
        assert_contains!(err.backtrace.to_string(), "Backtrace disabled");
        assert_contains!(err.provide_backtrace().to_string(), "Backtrace disabled");
    }

    let err = CurrencyFormatError::with_backtrace(ErrorKind::NoCurrency, NewBacktracePolicy::NoBacktrace);
    assert_eq!(err.backtrace.to_string(), "Backtrace disabled");
    assert_eq!(err.provide_backtrace().to_string(), "Backtrace disabled");

    let err = CurrencyFormatError::with_backtrace(ErrorKind::NoCurrency, NewBacktracePolicy::ForceCapture);
    assert_contains!(err.backtrace.to_string(), "force_capture");
    assert_contains!(err.provide_backtrace().to_string(), "force_capture");
}

#[test]
fn test_currency_format_error_other() {
    use parse_currency_another_01::*;
    // use crate::util::backtrace::NewBacktracePolicy;
    use project01::util::backtrace::NewBacktracePolicy;
    use anyhow::__private::kind::TraitKind;
    use thiserror::__private::AsDynError;
    use std::any::Any;
    use std::error::Error;

    let err = CurrencyFormatError::with_backtrace(ErrorKind::NoCurrency, NewBacktracePolicy::Default);

    // ??? What is it?
    let anyhow_kind = err.anyhow_kind();
    // anyhow::kind is private
    // let anyhow_kind: anyhow::kind::Trait = err.anyhow_kind();
    // let anyhow_kind: &dyn std::any::Any = &err.anyhow_kind();
    println!("anyhow_kind: {:?}", anyhow_kind.type_id());

    let std_err_src: Option<&dyn Error> = err.source();
    // T O D O: add support of it after appearing std::error::Error.provide() in stable build.
    assert!(std_err_src.is_none());

    let std_err: &dyn Error = err.as_dyn_error();
    assert!(std_err.is::<CurrencyFormatError>());
}



// -------------------------------------------------------------------------------------------------
//                     Error without source - simple variant.
// -------------------------------------------------------------------------------------------------


#[test]
fn test_amount_format_error_new() {
    use parse_amount_another_01::*;

    let err = ParseAmountError::new(ErrorKind::NoCurrency);
    assert_contains!(err.backtrace.to_string(), "capture");
    assert_eq!(err.kind, ErrorKind::NoCurrency);
    assert_contains!(err.provide_backtrace().to_string(), "capture");
}


#[test]
fn test_amount_format_error_with_backtrace() {
    use parse_amount_another_01::*;

    let err = ParseAmountError::with_backtrace(ErrorKind::IncorrectCurrency, NewBacktracePolicy::Default);
    assert_contains!(err.backtrace.to_string(), "capture");
    assert_eq!(err.kind, ErrorKind::IncorrectCurrency);

    let err = ParseAmountError::with_backtrace(ErrorKind::NoCurrency, NewBacktracePolicy::Capture);
    if is_anyhow_backtrace_enabled() {
        assert_contains!(err.backtrace.to_string(), "capture");
        assert_contains!(err.provide_backtrace().to_string(), "capture");
    } else {
        assert_contains!(err.backtrace.to_string(), "Backtrace disabled");
        assert_contains!(err.provide_backtrace().to_string(), "Backtrace disabled");
    }

    let err = ParseAmountError::with_backtrace(ErrorKind::IncorrectAmount, NewBacktracePolicy::NoBacktrace);
    assert_eq!(err.backtrace.to_string(), "Backtrace disabled");
    assert_eq!(err.provide_backtrace().to_string(), "Backtrace disabled");

    let err = ParseAmountError::with_backtrace(ErrorKind::NoCurrency, NewBacktracePolicy::ForceCapture);
    assert_contains!(err.backtrace.to_string(), "force_capture");
    assert_contains!(err.provide_backtrace().to_string(), "force_capture");
}


#[test]
fn test_amount_format_error_with_source() {
    use parse_amount_another_01::*;

    let err = ParseAmountError::with_source(ErrorKind::NoCurrency, ErrorSource::NoSource);
    assert_eq!(err.kind, ErrorKind::NoCurrency);
    assert_contains!(err.backtrace.to_string(), "capture");
    assert_contains!(err.provide_backtrace().to_string(), "capture");

    let err = ParseAmountError::with_source(ErrorKind::NoCurrency, ErrorSource::CurrencyFormatError(
        parse_currency_another_01::CurrencyFormatError::with_backtrace(parse_currency_another_01::ErrorKind::NoCurrency, NewBacktracePolicy::ForceCapture)));
    assert_eq!(err.kind, ErrorKind::NoCurrency);
    assert_contains!(err.backtrace.to_string(), "force_capture");
    assert_contains!(err.provide_backtrace().to_string(), "force_capture");

    let err = ParseAmountError::with_from(ErrorKind::NoCurrency,
        parse_currency_another_01::CurrencyFormatError::with_backtrace(parse_currency_another_01::ErrorKind::NoCurrency, NewBacktracePolicy::ForceCapture));
    assert_eq!(err.kind, ErrorKind::NoCurrency);
    assert_contains!(err.backtrace.to_string(), "force_capture");
    assert_contains!(err.provide_backtrace().to_string(), "force_capture");

    let err = ParseAmountError::with_source(ErrorKind::IncorrectCurrency, ErrorSource::CurrencyFormatError(
        parse_currency_another_01::CurrencyFormatError::with_backtrace(parse_currency_another_01::ErrorKind::NoCurrency, NewBacktracePolicy::ForceCapture)));
    assert_eq!(err.kind, ErrorKind::IncorrectCurrency);
    assert_contains!(err.backtrace.to_string(), "force_capture");
    assert_contains!(err.provide_backtrace().to_string(), "force_capture");

    let err = ParseAmountError::with_from(ErrorKind::IncorrectCurrency,
        parse_currency_another_01::CurrencyFormatError::with_backtrace(parse_currency_another_01::ErrorKind::NoCurrency, NewBacktracePolicy::ForceCapture));
    assert_eq!(err.kind, ErrorKind::IncorrectCurrency);
    assert_contains!(err.backtrace.to_string(), "force_capture");
    assert_contains!(err.provide_backtrace().to_string(), "force_capture");

    let err = ParseAmountError::with_source(ErrorKind::IncorrectAmount, ErrorSource::ParseBigDecimalError(
        bigdecimal::ParseBigDecimalError::Other("some decimal error".to_string())));
    assert_eq!(err.kind, ErrorKind::IncorrectAmount);
    assert_contains!(err.backtrace.to_string(), "capture");
    assert_contains!(err.provide_backtrace().to_string(), "capture");

    let err = ParseAmountError::with_from(ErrorKind::IncorrectAmount,
        bigdecimal::ParseBigDecimalError::Other("some decimal error".to_string()));
    assert_eq!(err.kind, ErrorKind::IncorrectAmount);
    assert_contains!(err.backtrace.to_string(), "capture");
    assert_contains!(err.provide_backtrace().to_string(), "capture");
}


#[test]
fn test_amount_format_error_with_source_666() {
    use parse_amount_another_01::*;

    let err = ParseAmountError::with_source(ErrorKind::NoCurrency, ErrorSource::SomeWithoutSource);
    // let err = ParseAmountError::with_source(ErrorKind::NoCurrency, ErrorSource::Some1FromInt(666));
    assert_eq!(err.kind, ErrorKind::NoCurrency);
    assert_contains!(err.backtrace.to_string(), "capture");
    assert_contains!(err.provide_backtrace().to_string(), "capture");
}


#[test]
fn test_amount_format_error_src() {
    use parse_amount_another_01::ErrorSource;
    use parse_currency_another_01::{ CurrencyFormatError, ErrorKind };

    let err = CurrencyFormatError::with_backtrace(ErrorKind::NoCurrency, NewBacktracePolicy::Default);
    assert_contains!(err.provide_backtrace().to_string(), "capture");

    let err_src: ErrorSource = err.into();
    // assert_eq!(err_src.type_id(), ErrorSource::CurrencyFormatError())
    match err_src {
        ErrorSource::CurrencyFormatError(_) => { }
        _ => { assert!(false, "Unexpected amount error source type.") }
    }
}

fn fn_anyhow_01() -> Result<i32, anyhow::Error> {
    std::fs::read_to_string("not-existent-file.txt").map(|_| 123) ?;
    Ok(124)
}
fn fn_anyhow_02() -> Result<i32, anyhow::Error> { fn_anyhow_01() }

#[test]
fn test_amount_format_error_src_from_anyhow() {
    use parse_amount_another_01::*;
    use std::fmt::Write;

    let err_res = fn_anyhow_02();
    let res = err_res.map_err(|anyhow_err| ParseAmountError::with_source(ErrorKind::IncorrectAmount, ErrorSource::SomeAnyHowError(anyhow_err)));

    let amount_err = res.err().unwrap();

    println!("amount_err from anyhow: {:?}", amount_err);
    println!("\n-------------------------------------------\n");

    let mut amount_err_as_str_with_backtrace = String::new();
    write!(amount_err_as_str_with_backtrace, "{:?}", amount_err).unwrap();

    println!("{}", amount_err_as_str_with_backtrace);

    if is_anyhow_backtrace_enabled() {
        assert_contains!(amount_err_as_str_with_backtrace, "fn_anyhow_01");
        assert_contains!(amount_err_as_str_with_backtrace, "fn_anyhow_02");
    }
}

// #[test]
// fn test_failed() {
//     assert!(false, "It should fail.")
// }
