



// pub struct Other01Struct {}


/*
pub fn add456(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add456(2, 2);
        assert_eq!(result, 4);
    }
}
*/



extern crate proc_macro;
extern crate syn;
// #[macro_use]
extern crate quote;

use proc_macro::TokenStream;
// use quote::quote;

#[proc_macro_derive(TlbormDerive22, attributes(tlborm_helper22))]
pub fn tlborm_derive22(_item: TokenStream) -> TokenStream {
    TokenStream::new()
}


#[proc_macro_derive(TlbormDerive, attributes(tlborm_helper))]
pub fn tlborm_derive(_item: TokenStream) -> TokenStream {
    TokenStream::new()
}

/*
#[proc_macro_derive(MyStaticTypedErrorDerive, attributes(my_static_types_error_attr_helper))]
pub fn my_static_types_error(input: TokenStream) -> TokenStream {
    // Construct a string representation of the type definition
    let s = input.to_string();

    // Parse the string representation
    let ast = syn::parse_derive_input(&s).unwrap();

    // Build the impl
    let gen = impl_hello_world(&ast);

    // Return the generated impl
    gen.parse().unwrap()
}


fn impl_hello_world(ast: &syn::DeriveInput) -> quote::Tokens {
    let name = &ast.ident;
    quote! {
        impl HelloWorld for #name {
            fn hello_world() {
                println!("Hello, World! My name is {}", stringify!(#name));
            }
        }
    }
}
*/


// use proc_macro::TokenStream;
use quote::quote;
// use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}


#[proc_macro_derive(MyStaticStructError)]
pub fn my_static_struct_error_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_my_static_struct_error(&ast)
}

fn impl_my_static_struct_error(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {

        #[allow(unused_imports)]
        #[allow(unused_qualifications)]
        impl #name {
            // It can be generated by macro
            pub fn new(kind: ErrorKind) -> Self {
                use crate::util::backtrace::NewBacktracePolicy;
                use crate::util::BacktraceInfo;
                Self { kind, backtrace: BacktraceInfo::new(), source: ErrorSource::NoSource }
            }
            // It can be generated by macro
            pub fn with_backtrace(kind: ErrorKind, backtrace_policy: crate::util::backtrace::NewBacktracePolicy) -> Self {
                use crate::util::backtrace::NewBacktracePolicy;
                use crate::util::BacktraceInfo;
                Self { kind, backtrace: BacktraceInfo::new_by_policy(backtrace_policy), source: ErrorSource::NoSource }
            }
            // It can be generated by macro
            pub fn with_source(kind: ErrorKind, source: ErrorSource) -> Self {
                use crate::util::backtrace::NewBacktracePolicy;
                use crate::util::BacktraceInfo;
                Self { kind, backtrace: BacktraceInfo::inherit_from(&source), source }
            }
            // It can be generated by macro
            // pub fn with_from<ES: Into<ErrorSource>>(kind: ErrorKind, source: ES) -> Self {
            //     use crate::util::backtrace::NewBacktracePolicy;
            //     use crate::util::BacktraceInfo;
            //     let src = source.into();
            //     Self { kind, backtrace: BacktraceInfo::inherit_from(&src), source: src }
            // }
        }

        #[allow(unused_imports)]
        #[allow(unused_qualifications)]
        impl crate::util::backtrace::BacktraceCopyProvider for #name {
            fn provide_backtrace(&self) -> crate::util::BacktraceInfo { self.backtrace.clone() }
        }

        #[allow(unused_imports)]
        #[allow(unused_qualifications)]
        impl core::fmt::Display for #name {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, "CurrencyFormatError  {}", self.kind)
            }
        }

        #[allow(unused_imports)]
        #[allow(unused_qualifications)]
        impl crate::util::backtrace::BacktraceCopyProvider for ErrorSource {
            fn provide_backtrace(&self) -> crate::util::BacktraceInfo {
                use crate::util::BacktraceInfo;
                match self {
                    ErrorSource::NoSource => { BacktraceInfo::empty() }
                    // TODO: generate for enums
                    // ErrorSource::ParseBigDecimalError(_)  => { BacktraceInfo::empty() }
                    // ErrorSource::CurrencyFormatError(src) => { src.provide_backtrace() }
                }
            }
        }

        #[allow(unused_imports)]
        #[allow(unused_qualifications)]
        impl core::fmt::Debug for ErrorSource {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                use ErrorSource::*;
                match self {
                    NoSource                      => { write!(f, "No source") }
                    // TODO: generate for enums
                    // CurrencyFormatError(ref src)  => { write!(f, "{:?}", src) }
                    // ParseBigDecimalError(ref src) => { write!(f, "{:?}", src) }
                }
            }
        }

    };
    gen.into()
}


